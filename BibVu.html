<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BibVu</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 40px; background: #f4f7f6; color: #333; }
        .container { max-width: 1400px; margin: auto; background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); }
        .header-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #3498db; padding-bottom: 10px; margin-bottom: 20px; }
        h2 { color: #1a3a5f; margin: 0; }
        #stats { font-size: 14px; color: #7f8c8d; font-weight: bold; }

        .filters { display: flex; gap: 15px; margin-bottom: 25px; flex-wrap: wrap; align-items: center; }
        input, select { padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; transition: border 0.3s; }
        input:focus { border-color: #3498db; outline: none; }
        input { flex-grow: 1; }

        .btn-download {
            background-color: #27ae60; color: white; border: none; padding: 10px 20px;
            border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px; transition: background 0.3s;
        }
        .btn-download:hover { background-color: #219150; }

        table { width: 100%; border-collapse: collapse; margin-top: 10px; table-layout: fixed; }
        th { background: #1a3a5f; color: white; padding: 12px; text-align: left; cursor: pointer; font-size: 14px; position: relative; }
        th:hover { background: #2c3e50; }

        /* Sort Icons */
        th::after { content: ' ⬘'; font-size: 10px; opacity: 0.3; }
        th.asc::after { content: ' ▲'; opacity: 1; color: #3498db; }
        th.desc::after { content: ' ▼'; opacity: 1; color: #3498db; }

        td { padding: 12px; border-bottom: 1px solid #eee; font-size: 14px; vertical-align: top; word-wrap: break-word; }
        tr:hover { background: #f9fcff; }

        /* Column Widths */
        .col-title { width: 40%; }
        .col-author { width: 15%; }
        .col-year { width: 8%; }
        .col-journal { width: 22%; }
        .col-key { width: 15%; }

        .key-link { font-family: 'Courier New', monospace; font-weight: bold; color: #e67e22; text-decoration: none; border: 1px solid #e67e22; padding: 2px 6px; border-radius: 4px; display: inline-block; font-size: 12px; }
        .key-link:hover { background: #e67e22; color: white; }
    </style>
</head>
<body>

<div class="container">
    <div class="header-row">
        <h2>BibVu: Sam's Reference Manager</h2>
        <div id="stats">Loading papers...</div>
    </div>

    <div class="filters">
        <input type="text" id="srch" placeholder="Search Title, Author or Key..." onkeyup="doSearch()">
        <select id="jFilt" onchange="doSearch()"><option value="">All Journals</option></select>
        <select id="yFilt" onchange="doSearch()"><option value="">All Years</option></select>
        <button class="btn-download" onclick="downloadBib()">Download Full .bib</button>
    </div>

    <table id="bt">
        <thead>
            <tr>
                <th class="col-title" onclick="sortTable(0, this)">Title</th>
                <th class="col-author" onclick="sortTable(1, this)">Author</th>
                <th class="col-year" onclick="sortTable(2, this)">Year</th>
                <th class="col-journal" onclick="sortTable(3, this)">Journal</th>
                <th class="col-key" onclick="sortTable(4, this)">Citation Key</th>
            </tr>
        </thead>
        <tbody id="tb"></tbody>
    </table>
</div>

<script>
    let data = [];
    let rawBibText = "";
    let sortConfig = { index: -1, direction: 'asc' }; // Tracks current sort state

    async function init() {
        try {
            const res = await fetch('updated_metadata.bib');
            rawBibText = await res.text();
            const entries = rawBibText.split(/@\w+\s*\{/).slice(1);

            data = entries.map(e => {
                const f = {};
                const entryKey = e.split(',')[0].trim();
                const lines = e.split('\n');
                lines.forEach(line => {
                    if (line.includes('=')) {
                        let [field, ...valParts] = line.split('=');
                        field = field.trim().toLowerCase();
                        let value = valParts.join('=').trim();
                        value = value.replace(/,$/, '').replace(/^[\{\"]/, '').replace(/[\}\"]$/, '').replace(/[\{\}]/g, '');
                        f[field] = value.trim();
                    }
                });

                return {
                    key: entryKey,
                    title: f.title || "Untitled",
                    author: f.author || "Unknown",
                    year: f.year || "N/A",
                    journal: f.journal || "Unknown",
                    doi: f.doi || ""
                };
            });

            const jf = document.getElementById('jFilt');
            const yf = document.getElementById('yFilt');
            [...new Set(data.map(d=>d.journal))].filter(Boolean).sort().forEach(j => jf.add(new Option(j,j)));
            [...new Set(data.map(d=>d.year))].sort((a,b)=>b-a).forEach(y => yf.add(new Option(y,y)));

            render(data);
        } catch (err) {
            console.error("Fetch error:", err);
            document.getElementById('tb').innerHTML = "<tr><td colspan='5'>Error loading .bib. Use a local server.</td></tr>";
        }
    }

    function formatAuthor(authorStr) {
        if (!authorStr || authorStr === "Unknown") return "Unknown";
        let clean = authorStr.replace(/\\/g, "");
        const authors = clean.split(/\s+and\s+/i);
        let first = authors[0].trim();
        if (first.includes(',')) {
            first = first.split(',')[0].trim();
        } else {
            const parts = first.split(' ');
            first = parts[parts.length - 1].trim();
        }
        return authors.length > 1 ? `${first} et al.` : first;
    }

    function render(list) {
        document.getElementById('stats').innerText = `Showing ${list.length} of ${data.length} papers`;
        document.getElementById('tb').innerHTML = list.map(i => `
            <tr>
                <td>${i.title}</td>
                <td>${formatAuthor(i.author)}</td>
                <td><b>${i.year}</b></td>
                <td><i>${i.journal}</i></td>
                <td><a href="${i.doi ? 'https://doi.org/'+i.doi : 'https://scholar.google.com/scholar?q='+encodeURIComponent(i.title)}" target="_blank" class="key-link">${i.key}</a></td>
            </tr>`).join('');
    }

    function doSearch() {
        const s = document.getElementById('srch').value.toLowerCase();
        const j = document.getElementById('jFilt').value;
        const y = document.getElementById('yFilt').value;
        const filtered = data.filter(d =>
            (d.title.toLowerCase().includes(s) || d.author.toLowerCase().includes(s) || d.key.toLowerCase().includes(s)) &&
            (!j || d.journal === j) && (!y || d.year === y)
        );
        render(filtered);
    }

    // UPDATED: Column-wise Toggling Sort
    function sortTable(n, el) {
        const map = ['title', 'author', 'year', 'journal', 'key'];

        // Toggle direction if clicking same column, else reset to asc
        if (sortConfig.index === n) {
            sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc';
        } else {
            sortConfig.index = n;
            sortConfig.direction = 'asc';
        }

        // Update UI Arrows
        document.querySelectorAll('th').forEach(th => th.classList.remove('asc', 'desc'));
        el.classList.add(sortConfig.direction);

        data.sort((a, b) => {
            let valA = a[map[n]].toString().toLowerCase();
            let valB = b[map[n]].toString().toLowerCase();

            let comparison = valA.localeCompare(valB, undefined, {numeric: true});
            return sortConfig.direction === 'asc' ? comparison : -comparison;
        });

        doSearch(); // Maintain current filters while sorting
    }

    function downloadBib() {
        if (!rawBibText) return;
        const blob = new Blob([rawBibText], { type: 'text/plain' });
        const elem = window.document.createElement('a');
        elem.href = window.URL.createObjectURL(blob);
        elem.download = "updated_metadata.bib";
        document.body.appendChild(elem);
        elem.click();
        document.body.removeChild(elem);
    }

    init();
</script>
</body>
</html>
